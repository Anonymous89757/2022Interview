[TOC]

## RPC

#### 1.什么是RPC

比较正式的定义是：`一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的思想`。

没看懂？说的通俗一点就是：`客户端在不知道调用细节的情况下，调用存在于远程计算机上的某个对象，就像调用本地应用程序中的对象一样`。

比如说有两台服务器：A 和 B，一个应用部署在 A 服务器上，想要调用 B 服务器上某个应用提供的函数/方法，

由于跨应用跨服务器，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据，这种调用的方式就是 RPC，如下图所示。

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/RXvHpViaz3EpI2cfJHR5ecE0s0Vn8mJTXn8Vmk887MI1m7nXLPibXmickpT9WtCEPfY5amNAj2UMjDMiaGxicOv0z0Q/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)

如果在一个应用内直接调用， 这就是本地调用了，如下图所示。

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/RXvHpViaz3EpI2cfJHR5ecE0s0Vn8mJTXNmVrDz3hdm3gicf2GNrhibI3P28vTm8yMuQYJdKhhUGZ5WQ3mfNfjBFA/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)

#### 2.为什么需要RPC

上面简单介绍了一下 RPC 是什么，那大家有没有想过为什么需要 RPC？一项新技术出来总是为了解决某些实际的业务或架构问题。

下面以电商业务为例介绍一下技术架构的演变。

##### 单体架构

通俗地讲，「单体应用」就是将应用程序的所有功能都打成一个部署包。

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/RXvHpViaz3EpI2cfJHR5ecE0s0Vn8mJTXZOtibF8I2Z0B2gsfO8eYtYNfxlGBm0jVhFOddmqoD8tD2IT4G5tsibCA/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)

从上面的架构图总结一下单体架构的特点：

- 所有的功能集成在一个项目工程中；
- 通过分层架构，上层调用下层接口，所有的调用都在应用内完成；
- 所有的功能打一个 war 包部署到服务器；
- 应用与数据库分开部署；

当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。当流量稍微大一点可以通过部署应用集群和数据库集群来提高系统的性能。

随着业务逐渐复杂，应用的外部流量压力增加，团队成员越来越多，单体应用架构的缺点也就慢慢暴露了。

**缺点一：持续交付周期拉长**

单体应用变大后构建和部署时间也相应地延长，不利于频繁部署，阻碍持续交付。即使在仅仅更改了一行代码的情况下，软件开发人员需要花费几十分钟甚至超过一个小时的时间对所有代码进行编译，并接下来花费大量的时间重新部署刚刚生成的产品，以验证自己的更改是否正确。

**缺点二：高耦合**

某个模块出现了死循环，导致内存溢出，整个应用都会挂掉。

**缺点三：伸缩性差**

系统的扩容只能针对应用进行扩容，不能做到对某个功能模块进行扩容，扩容后必然带来资源浪费的问题。

**缺点四：技术栈受限**

单应用内一般只会选择同一种技术栈，比如说很少在一个应用内同时才用 Java 和 Go 语言。

为了解决这些问题，微服务架构就应运而生了。

##### 微服务架构

目前我们所说的微服务架构是经过了多年的迭代发展而形成，像以前用的 SOAP、ESB 等技术这里就不再赘述了。

单体架构发展到一定阶段必然会遇到瓶颈，怎么解决呢？首先想到的办法就是把单体架构进行拆分，大的问题难以解决就把它拆分成小的问题逐个解决，这就是分而治之的思想。

我们试着把前面的单体架构根据业务模块拆分为多个微服务：商品服务、购物车服务、订单服务、用户服务等等。

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/RXvHpViaz3EpI2cfJHR5ecE0s0Vn8mJTXIfkvfN1N83omNwnhgbZnV4dEpgjl2YF6HPhFgk9c7GKqJh6nbd0BYQ/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)

这些微服务在之前的单体应用架构中可能是一个业务模块，业务模块之前的调用直接使用本地调用即可。

服务拆分后，这些微服务可能部署在不同的机器节点上，那服务间如何调用呢？

这个时候就该我们的女主角 RPC 闪亮登场了，RPC 就是为了解决远程服务间调用问题。关于RPC 如何实现调用以及内部原理，后面的文章会详细讲解，这里只是简单引入一下，大家有个大致的概念即可。

服务间调用的问题解决了，我们会发现微服务架构有很多优点：

**优点一：团队独立**

团队根据微服务划分职责，微服务可独立编译、测试、部署，依赖关系清晰明了。

**优点二：技术栈独立**

各服务可根据业务特点自行选择技术栈，对外暴露的接口与具体实现无关。

**优点三：易伸缩**

业务团队可根据实际的负载情况动态决定部署规模，避免资源浪费。

#### 3.RPC 框架典型的架构

典型的 RPC 架构大致可以分为三个部分：

（1）服务提供者（RPC Server）：运行在服务器端，提供服务接口定义与服务实现类。

（2）注册中心（Registry）：运行在服务器端，负责将本地服务发布成远程服务，管理远程服务，提供给服务消费者使用。

（3）服务消费者（RPC Client）：运行在客户端，通过远程代理对象调用远程服务。

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/RXvHpViaz3ErdH52Kvy5icBeIKwVtLHlkd1JuSzAPw4Mw8wh2cJskRJbqdkJrveia9LnkjVxwcDGicoC5XiadO8M4NA/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)

通过上面的图可以看出，一次简单的 RPC 调用可以分为以下几个步骤：

（1）服务提供者启动后主动向服务注册中心注册机器ip、端口以及提供的服务列表；

（2）服务消费者启动时向服务注册中心获取服务提供方地址列表，在本地缓存一份；

（3）服务消费者通过本地调用的方式调用服务，调用模块收到请求后通过负载均衡策略选取合适的远程服务地址；

（4）协议模块负责将方法、入参等信息序列化(编码)成能够进行网络传输的消息体，并将消息通过网络发送给服务端；

（5）服务端收到消息后进行解码(反序列化操作)。

（6）根据解码结果调用本地的服务进行相关处理；

（7）服务端将处理返回的结果进行序列化（编码），并将结果通过网络发送至服务消费者；

（8）服务消费者收到消息后进行解码最终得到结果；

#### 4.RPC 核心功能

一个完整的商用 RPC 框架有很多功能，最最核心的基本就是三个：**服务寻址**、**数据编解码**、**网络传输**。

##### 服务寻址

如果是本地调用，被调用的方法在同一个进程内，操作系统或虚拟机可以地址空间找到；但是在远程调用中，这是行不通的，因为两个进程的地址空间是完全不一样的，并且也无法知道远端的进程在何处。

要想实现远程调用，我们需要对服务消费者和服务提供者进行约束：

- 在远程过程调用中所有的函数都必须有一个ID，这个 ID 在整套系统中是唯一确定的。
- 服务消费者在做远程过程调用时，发送的消息体中必须携带这个 ID。
- 服务消费者和服务提供者分别维护一个函数和 ID 的对应表。

当服务消费者需要进行远程调用时，它就查一下这个表，找出对应的 ID，然后把它传给服务端，服务端也通过查表，来确定客户端需要调用的函数，然后执行相应函数的代码。

上面说的可能比较抽象，通俗一点就是**服务消费者如何寻找服务提供者**，这就是服务寻址。

![图片](https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3ErdH52Kvy5icBeIKwVtLHlkdB4w27aKFkcXnAmINX557zK0WVp7SCfrXicGu4fqicf9IKDwI0BSp5HNw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)



服务寻址的实现方式有很多种，比较常见的是：**服务注册中心**。要调用服务，首先你需要一个服务注册中心去查询对方服务都有哪些实例，然后根据负载均衡策略择优选一。

像 Dubbo 框架的服务注册中心是可以配置的，官方推荐使用 Zookeeper。

##### 数据编解码（序列化和反序列化）

对计算机网络稍微有一点了解的同学都知道，数据在网络中传输是二进制的：01010101010101010，类似这种，只有二进制数据才能在网络中传输。

那一个客户端调用远程服务的一个方法，像方法入参这些必然需要转换成二进制才能进行传输，这种将对象转换成二进制流的过程就叫做**序列化编码**。

服务端接收到二进制流不能识别，势必要将二进制流转换成对象，这个逆过程就叫做**反序列化解码**。

一般场景下是可以将序列化编码简称为序列化。

> 敲黑板：
>
> 如果非要较真，严格来说序列化和编码是两个不同的概念，我画一张图大家都明白了。

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/RXvHpViaz3ErdH52Kvy5icBeIKwVtLHlkd8NB5K4PlI4qwaPFZELic7F55SdHXzV03BsFwBvianU0QlibFSCVib0TZag/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)

序列化和编码的对比

> 序列化+编码的逆过程就是：解码+反序列化。

##### 网络传输

提起网络传输大家脑海里肯定马上就能想到 TCP/IP四层模型、OSI 七层模型，那通常 RPC 会选择那一层作为传输协议呢？

在回答这个问题前我们先看下 RPC 需要网络传输实现什么功能。

客户端的数据经过序列化+编码后，就需要通过网络传输到服务端。网络传输层需要把前面说的函数 ID 和序列化后的参数字节流传给服务端，服务端处理完然后再把序列化后的调用结果传回客户端。

原则上只要能实现上面这个功能的都可以作为传输层来使用，具体协议没有限制。

我们先来看下 TCP 协议，TCP 连接可以是按需连接，需要调用的时候就先建立连接，调用结束后就立马断掉，也可以是长连接，客户端和服务器建立起连接之后保持长期持有，不管此时有无数据包的发送，可以配合心跳检测机制定期检测建立的连接是否存活有效。

由此可见 TCP 的性能确实很好，因此市面上大部分 RPC 框架都使用 TCP 协议，但也有少部分框架使用其他协议，比如 gRPC 就基于 HTTP2 来实现的。

> 敲黑板：
>
> 数据编解码和网络传输可以有多种组合方式，比如常见的有：HTTP+JSON, Dubbo 协议+TCP 等。

#### 5.常见的 RPC 框架

说了这么多 RPC 相关的技术，我们盘点一下市面上常用的 RPC 框架。

- RMI（Sun/Oracle）
- Thrift（Facebook/Apache）
- gRPC（Google）
- Finagle（Twitter）
- Dubbo（阿里巴巴/Apache）
- Motan（新浪微博）
- brpc（百度/Apache）
- ……欢迎大家补充其他的。

#### 6.服务注册发现机制

##### 6.1 引入服务注册与发现组件的原因

先来看一个问题，假如现在我们要做一个商城项目，作为架构师的你应该怎样设计系统的架构？你心里肯定在想：这还不容易直接照搬淘宝的架构不就行了。但在现实的创业环境中一个项目可能是九死一生，如果一开始投入巨大的人力和财力，一旦项目失败损失就很大。

作为一位有经验的架构师需要结合公司财力、人力投入预算等现状选择最适合眼下的架构才是王道。大型网站都是从小型网站发展而来，架构也是一样。

任何一个大型网站的架构都不是从一开始就一层不变的，而是随着用户量和数据量的不断增加不断迭代演进的结果。

在架构不断迭代演进的过程中我们会遇到很多问题，**技术发展的本质就是不断发现问题再解决问题，解决问题又发现问题**。

##### 6.2 单体架构

在系统建立之初可能不会有特别多的用户，将所有的业务打成一个应用包放在tomcat容器中运行，与数据库共用一台服务器，这种架构一般称之为单体架构。

![图片](https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EqZWdtQfKJ6VyZkvWCspunYaoXBlAPZwK8UjsoVgmFJkyY1ibaH64bC3FNPsyicV35gXbia90XVV3dTg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

在初期这种架构的效率非常高，根据用户的反馈可以快速迭代上线。但是随着用户量增加，一台服务的内存和CPU吃紧，很容易造成瓶颈，新的问题来了怎么解决呢？

##### 6.3 应用于数据分离

单实例很容易造成单点问题，比如遇到服务器故障或者服务能力瓶颈，那怎么办？聪明的你肯定想到了，用集群呀。

![图片](https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EqZWdtQfKJ6VyZkvWCspunYvV8EkicsccxwQwPnS3BoMvdQJyRQqM0FqGScRxWicuk1TlnhewYuiaZTA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

集群部署是指将应用部署在多个服务器或者虚机上，用户通过服务均衡随机访问其中的一个实例，从而使多个实例的流量均衡，如果一个实例出现故障可以将其下线，其他实例不受影响仍然可以对外提供服务。

随着用户数量快速增加，老板决定增加投入扩大团队规模。开发团队壮大后效率并没有得到显著的提高，以前小团队可以一周迭代上线一次，现在至少需要两到三周时间。

业务逻辑越来越复杂，代码间耦合很严重，修改一行代码可能引入几个线上问题。架构师意识到需要进行架构重构。

##### 6.4 微服务架构

当单体架构演进到一定阶段后开发测试的复杂性都会成本增加，团队规模的扩大也会使得各自工作耦合性更严重，牵一发而动全身就是这种场景。

单体架构遇到瓶颈了，微服务架构就横空出世了。微服务就是将之前的单体服务按照业务维度进行拆分，拆分粒度可大可小，拆分时机可以分节奏进行。最佳实践是先将一些独立的功能从单体中剥离出来抽成一个或多个微服务，这样可以保障业务的连续性和稳定性。

![图片](https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EqZWdtQfKJ6VyZkvWCspunYMmcRDe3mDXd6SJ3QZWfUCr0odRBoXibPw32rhfDkowIpJr5VzGYQEfQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

如上图将一个商用应用拆分为六个独立微服务。六个微服务可以使用Docker容器化进行多实例部署。

架构演化到这里遇到了一个难题，如果要查询用户所有的订单，用户服务可能会依赖订单服务，用户服务如何与订单服务交互呢？订单服务有多个实例该访问哪一个？

**（1）服务地址硬编码**

服务的地址写死在数据库或者配置文件，通过访问DNS域名进行寻址路由。

![图片](https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EqZWdtQfKJ6VyZkvWCspunYu0CxTXS1ms07tEicD9jrQapfBByGLFVxt6icW6CQWZ6XA3c4gOS2MaTw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

服务B的地址硬编码在数据库或者配置文件中，服务A首先需要拿到服务B的地址，然后通过DNS服务器解析获取其中一实例的真实地址，最后可以向服务B发起请求。

如果遇到大促活动需要对服务实例扩容，大促完需要对服务实例进行下线，运维人员要做大量的手工操作，非常容易误操作。

**（2）服务动态注册与发现**

服务地址硬编码还有一个非常致命的问题，如果一台实例挂了，运维人员可能不能及时感知到，导致一部分用户的请求会异常。

引入服务注册与发现组件可以很好解决上面遇到的问题，避免过多的人工操作。

#### 7.服务注册与发现基本原理

服务注册与发现是分为注册和发现两个关键的步骤。

**服务注册**：服务进程在注册中心注册自己的元数据信息。通常包括主机和端口号，有时还有身份验证信息，协议，版本号，以及运行环境的信息。

**服务发现**：客户端服务进程向注册中心发起查询，来获取服务的信息。服务发现的一个重要作用就是提供给客户端一个可用的服务列表。

##### 7.1 服务注册

服务注册有两种形式：客户端注册和代理注册。

**客户端注册**

客户端注册是服务自己要负责注册与注销的工作。当服务启动后注册线程向注册中心注册，当服务下线时注销自己。

![图片](https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EqZWdtQfKJ6VyZkvWCspunY3e7egouVNTWZX3Qgib1dEMXjPDAn05ibWuo3SvYVkDiaGeZuxMibrtVoXA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)这种方式的缺点是注册注销逻辑与服务的业务逻辑耦合在一起，如果服务使用不同语言开发，那需要适配多套服务注册逻辑。

**代理注册**

代理注册由一个单独的代理服务负责注册与注销。当服务提供者启动后以某种方式通知代理服务，然后代理服务负责向注册中心发起注册工作。

![图片](https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EqZWdtQfKJ6VyZkvWCspunYX8IicOrwYpcCg9wJIWIFGtjgiaapgiaJIFCL4bGibH1zFiarxIVB8jib2jTg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

这种方式的缺点是多引用了一个代理服务，并且代理服务要保持高可用状态。

##### 7.2 服务发现

务发现也分为客户端发现和代理发现。

**客户端发现**

客户端发现是指客户端负责向注册中心查询可用服务地址，获取到所有的可用实例地址列表后客户端根据负载均衡算法选择一个实例发起请求调用。

![图片](https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EqZWdtQfKJ6VyZkvWCspunYEDaG9gB5GjrILCf7846KazKia8DWic7sKeP5eTVClTj5xEzTjWQu5JicA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

这种方式非常直接，客户端可以控制负载均衡算法。但是缺点也很明显，获取实例地址、负载均衡等逻辑与服务的业务逻辑耦合在一起，如果服务发现或者负载平衡有变化，那么所有的服务都要修改重新上线。

**代理发现**

代理发现是指新增一个路由服务负责服务发现获取可用的实例列表，服务消费者如果需要调用服务A的一个实例可以直接将请求发往路由服务，路由服务根据配置好的负载均衡算法从可用的实例列表中选择一个实例将请求转发过去即可，如果发现实例不可用，路由服务还可以自行重试，服务消费者完全不用感知。

#### 8.心跳机制

如果服务有多个实例，其中一个实例出现宕机，注册中心是可以实时感知到，并且将该实例信息从列表中移出，也称为摘机。

如何实现摘机？业界比较常用的方式是通过心跳检测的方式实现，心跳检测有**主动**和**被动**两种方式。

**被动检测**是指服务主动向注册中心发送心跳消息，时间间隔可自定义，比如配置5秒发送一次，注册中心如果在三个周期内比如说15秒内没有收到实例的心跳消息，就会将该实例从列表中移除。

![图片](https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EqZWdtQfKJ6VyZkvWCspunYpuiaNYpTvqkctibxjnf0nxtj6FudibJsjib6motU8o1FgCSPatpEz0GUuA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

上图中服务A的实例2已经宕机不能主动给注册中心发送心跳消息，15秒之后注册就会将实例2移除掉。

**主动检测**是注册中心主动发起，每隔几秒中会给所有列表中的服务实例发送心跳检测消息，如果多个周期内未发送成功或未收到回复就会主动移除该实例。

![图片](https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EqZWdtQfKJ6VyZkvWCspunYWs9ZXnDO0MuM05IrLmGKq2yHCmLvE0xqXticoEk07S22sUaOsh1puFQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)